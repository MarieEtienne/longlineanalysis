{
    "contents" : "# RunBayesEstimation\n#' RunBayesEstimation runs the estimation of lambdaT and lambdaNT and produce abundance indices \n#' @param llData an object of class longline\n#' @param MEM the version of the model, default is 1\n#' @param nIter number of MCMC iterations kept, default is 2000\n#' @param burnin  number of MCMC iterations dropped for the bruning period\n#' @param filePath  the path where results and figure should be stored\n#' @param parPrior a 2 components vector on the probability of espace pe~dbeta(parPrior[1], parPrior[2])\n#' @param peConst should the probability of escape be considered as constant, default is FALSE prior for all log.mu*, log.lambda*F* parameters, default value=0.5\n#' @param tau.lambda the precision used in the lognormal\n#' @export\n#' @return a list of abundance indice, and write some figures and tables in the directory specified in pathFile\n#\n\nRunBayesEstimation <- function(llData, MEM=1, nIter =2000, burnin = 500, filePath=\"\", parPrior=c(1,1), peConst =F, tau.lambda=0.5)\n{\n  dataName <- as.list(sys.call() )$llData\n  cat(paste0('Now running indices estimation on ', dataName, '\\n')) \n  data.list  <-  FormatDataForJags(llData, tau.lambda=tau.lambda)\n  init.list  <-  FormatInitForJags(llData, MEM = MEM, peConst = peConst)\n  ## define Model name\n  modelName <- paste0('MEM', MEM)\n  if(\"Fact2\" %in% names(llData)){\n     modelName <- paste0(modelName, 'AdjustFact')\n  }\n  if(peConst)\n    modelName <- paste0(modelName,'ConstantPe')\n  \n  modelName <- paste0(modelName,'.txt')\n     \nprint(modelName)     \n  jagsRun <- jags.model(file=system.file(package='longline', 'jags', modelName), data = data.list, inits = init.list, n.adapt = 100, n.chains = 1)\n  update(jagsRun, burnin)\n  out.samples <- jags.samples(jagsRun, c(\"log.mu1\",\"log.mu2\", \"log.lambda1F1\", \"log.lambda2F1\", \"pe\"), n.iter=nIter)\n\npostIndices <- PostIndicesPlot(llData, out.samples, who=\"TF1\", yLim = range(c(0)),xLab = levels(llData$Fact1), fileOut = file.path(filePath, paste0(dataName, '-MEM=',MEM, 'peConst=', peConst, '.pdf')) )\n\n  ### save indices\n  res <- Reduce('rbind',tapply(postIndices$index, postIndices$Fact1, \n                               function(d) {\n                                 c(summary(d), sd(d), sd(d)/mean(d))\n                               }))\n  colnames(res) <- c(names(summary(rnorm(10))), \"sd\", \"cv\")\n  rownames(res) <- rep(\"\", nrow(res))\n  res <- cbind(data.frame(Fact1=levels(llData$Fact1)), res)\n  \n  write.table(file = file.path(filePath,  paste0(dataName,'-MEM=', MEM,'-peConst=', peConst, '.csv')), res, sep=\";\", row.names=F)\n  save(file = file.path(filePath,  paste0(dataName,'-MEM=', MEM,'-peConst=', peConst, '.Rd')), list=\"out.samples\" )\n  return(postIndices)\n}\n\n# postMean <- function(longline, outmcmc,  peConst=F)\n# {\n#   NYear <- longline$NYear\n#   NArea <- longline$NArea\n#   outl1 <- apply(outmcmc$lambda1,1, mean)\n#   outl2 <- apply(outmcmc$lambda2,1, mean)\n#   outpe <- apply(outmcmc$pe, 1, mean)\n#   estimate <- data.frame(Year=rep(NA, NYear*NArea), Area=rep(NA, NYear*NArea),\n#                          lambdaT=rep(NA, NYear*NArea), lambdaNT=rep(NA, NYear*NArea), \n#                          pe=rep(NA, NYear*NArea))\n#   \n#   yearunique = as.numeric(levels(as.factor(longline$Year)))\n#   areaunique = as.numeric(levels(as.factor(longline$Area)))\n#   compt=1\n# \n#   \n# #   for( a in 1:NArea){\n# #     provlambdaT= data.frame(Year=NULL, Value=NULL)\n# #     provlambdaNT= data.frame(Year=NULL, Value=NULL)\n# #     for( y in 1:NYear)\n# #     {\n# #       if(sum(longline$Year==yearunique[y] & longline$Area==areaunique[a])>1)\n# #       {\n# #         n <- length(outmcmc$lambda1[1,,])\n# #         p1 <- data.frame(Year=rep(yearunique[y],n), Value=outmcmc$lambda1[(a-1)*NYear+y,,])\n# #         p2 <- data.frame(Year=rep(yearunique[y],n), Value=outmcmc$lambda2[(a-1)*NYear+y,,])\n# #         provlambdaT = rbind(provlambdaT, p1)\n# #         provlambdaNT = rbind(provlambdaNT, p2)\n# #       }\n# #     }\n#     \n#     \n# for(a in 1:NArea)   \n#   {\n#   for(y in 1:NYear)\n#     {\n#       ind <- which(longline$Year==yearunique[y] & longline$Area==areaunique[a] )\n#       if(length(ind>0)){\n#         estimate[compt,1] <- yearunique[y]\n#         estimate[compt,2] <- areaunique[a] \n#         estimate[compt,3] <- mean(outmcmc$lambda1[(a-1)*NYear + y ,,])\n#         estimate[compt,4] <- mean(outmcmc$lambda2[(a-1)*NYear+y,,])\n#         estimate[compt,5] <- ifelse( peConst,mean(outmcmc$pe) , mean(outmcmc$pe[(a-1)*NYear+y,,]))\n#                                  #outl1[(a-1)*NYear+y], outl2[(a-1)*NYear+y], outpe[(a-1)*NYear+y])\n#         compt=compt+1\n#       }\n#     }\n#   }\n#   if(compt<=nrow(estimate))\n#   {\n#     estimate <- estimate[-(compt:nrow(estimate)),]\n#   }\n#   return(estimate)\n# \n# }\n# \n# postSummary <- function(longline, outmcmc, peConst=F)\n# {\n#   NYear <- longline$NYear\n#   NArea <- longline$NArea\n#   Year  <- rep(NA, NYear*NArea)\n#   Area  <- rep(NA, NYear*NArea)\n#   outl1 <- apply(outmcmc$lambda1,1, summary)\n#   outl2 <- apply(outmcmc$lambda2,1, summary)\n#   outpe <- apply(outmcmc$pe, 1, summary)\n#   nrows.tot <- NYear*NArea\n#   estimate <- list(lambdaT=matrix(NA, nrow=NYear*NArea, ncol=8), lambdaNT=matrix(NA, nrow=NYear*NArea, ncol=8), \n#                          pe=matrix(NA, nrow=NYear*NArea, ncol=8)\n#                    )\n#   \n#   colnames(estimate$lambdaT)=c(unlist(strsplit(outl1[,1],\":\"))[seq(1,11,2)], \"sd\", \"cv\")\n#   colnames(estimate$lambdaNT)=c(unlist(strsplit(outl2[,1 ],\":\"))[seq(1,11,2)], \"sd\", \"cv\")\n#   colnames(estimate$pe)=c(unlist(strsplit(outl1[,1],\":\"))[seq(1,11,2)],\"sd\", \"cv\")\n#   yearunique = as.numeric(levels(as.factor(longline$Year)))\n#   areaunique = as.numeric(levels(as.factor(longline$Area)))\n#   compt=1\n#   for(a in 1:NArea)\n#     {\n#     for(y in 1:NYear)\n#     {\n#       outl1num=as.numeric(unlist(strsplit(outl1[,(a-1)*NYear+y],\":\"))[seq(2,12,2)])\n#       outl2num=as.numeric(unlist(strsplit(outl2[,(a-1)*NYear+y],\":\"))[seq(2,12,2)])\n#       if(! peConst)\n#         outpenum=as.numeric(unlist(strsplit(outpe[,(a-1)*NYear+y],\":\"))[seq(2,12,2)])\n#       else\n#         outpenum=as.numeric(unlist(strsplit(outpe,\":\"))[seq(2,12,2)])\n#       \n#       if(sum(longline$Year==yearunique[y] & longline$Area==areaunique[a])>1)\n#       {\n#         Year[compt] <- yearunique[y]\n#         Area[compt] <- areaunique[a] \n#         estimate$lambdaT[compt,1:7] <- c(outl1num,sd(outmcmc$lambda1[(a-1)*NYear+y,,]))\n#         estimate$lambdaNT[compt,1:7] <- c(outl2num, sd(outmcmc$lambda2[(a-1)*NYear+y,,]))\n#         estimate$lambdaNT[compt,8] <- estimate$lambdaNT[compt,7] / estimate$lambdaNT[compt,4]\n#         estimate$lambdaT[compt,8] <- estimate$lambdaT[compt,7] / estimate$lambdaT[compt,4]\n#           if(!peConst){\n#         estimate$pe[compt,1:7] <- c(outpenum, sd(outmcmc$pe[(a-1)*NYear+y,,]))\n#           }else{\n#             estimate$pe[compt,1:7] <- c(outpenum, sd(outmcmc$pe))\n#           }\n#         estimate$pe[compt,8] <- estimate$pe[compt,7] / estimate$pe[compt,4]\n#               \n#         compt=compt+1\n#       }\n#     }\n#   }\n#     \n#     \n#   if(compt<=nrows.tot)\n#   {\n#     Year <- Year[-(compt:nrows.tot )]\n#     Area <- Area[-(compt:nrows.tot )]\n#     estimate$lambdaT <- estimate$lambdaT[-(compt:nrows.tot ),]\n#     estimate$lambdaNT <- estimate$lambdaNT[-(compt:nrows.tot ),]\n#     estimate$pe <- estimate$pe[-(compt:nrows.tot ),]\n#     \n#   }\n#   rownames(estimate$lambdaT)= (paste(Area, Year, sep=\"-\"))\n#   rownames(estimate$lambdaNT)=rownames(estimate$lambdaT)\n#   return(estimate)\n#   \n# }",
    "created" : 1426607274282.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3911801579",
    "id" : "EB4741B4",
    "lastKnownWriteTime" : 1426663419,
    "path" : "~/EnCours/PackageDvp/Svn/longline/R/LonglineBayes.R",
    "project_path" : "R/LonglineBayes.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}