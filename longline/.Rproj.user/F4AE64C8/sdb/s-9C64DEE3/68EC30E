{
    "contents" : "# longline\n#' longline is used to create a longline object. \n#' \n#' @param fact1 a factor vector, for which which indices will be computed\n#' @param fact2 an opional  factor vector which should be accounted for in the \n#' definition of the indices\n#' @param nt a numeric vector of the number of individuals of target species\n#'  caught\n#' @param nnt a numeric vector of the number of individuals of non target \n#' species caught\n#' @param nb a numeric vector of  the number of still baited hooks\n#' @param ne an optional vector of  the number of empty hooks, if NULL, \n#' then empty hooks are considered as missing information\n#' @param s a numeric vector of soaktime\n#' \n#' @export\n#' @return an object of class longline \n#\n#' @examples\n#' N <- 20\n#' n <- rep(200,N)\n#' s <- rep(100, N)\n#' dataSim <- rmultinom(n=N, size=n, prob=c(.3, .1, .2, .4) )\n#' testLongline <- longline(fact1 = as.factor(sample(2004:2006, size=N,\n#' replace=TRUE)),  nb=dataSim[1,], nt=dataSim[,2], nnt=dataSim[,3], ne=dataSim[,4], s=s)\n\n\nlongline <- function(fact1, fact2=NULL,  nt, nnt, nb, ne=NULL, s)\n{\n  ne.missing <- F\n  nLines <- length(fact1)\n  if(is.null(ne)){\n    ne.missing <- T\n    ne=rep(NA,nLines)\n  }\n  if( nLines == length(nt) &\n      nLines == length(nnt) &\n      nLines == length(nb) & \n      nLines == length(ne) & \n      nLines == length(s) )\n    {\n      if(ne.missing)\n        n=nt+nnt+nb\n      else\n      {\n        ne[is.na(ne)] <- 0\n        n=nt+nnt+nb+ne\n      }\n      Fact1   <- as.factor(fact1)\n      if(!is.null(fact2))\n        Fact2   <- as.factor(fact2)\n      NFact1  <- nlevels(Fact1)\n      if(!is.null(fact2))\n        NFact2  <- nlevels(Fact2)\n      NData  <- nLines\n      nb[is.na(nb)] <- 0\n      ## same soaktime  within fact1,fact2 ?\n      cv.soaktime <- sd(s,na.rm = T)  /mean(s, na.rm = T)\n      sames <- (cv.soaktime < 0.01)\n       \n      res <- list(Fact1=Fact1, NFact1=NFact1, NData=NData, \n                  Ne=ne, N=n, NT=nt, NNT=nnt, Nb=nb, S=s, sameS=sames)        \n      if(!is.null(fact2))\n        res <- c(res, list(NFact2=NFact2, Fact2=Fact2))\n    }\n  else\n    {\n      print(\"Lengths of the vectors differ\")\n      return (-1)\n    }\n  class(res) <- c(\"longline\", \"list\")\n  return(res)\n}\n\n\n\n# is.longline\n#' is.longline is used to checked wheter or not the object is of class longline\n#' \n#' @param x any object to te tested\n#' @export\n#' @return a boolean, TRUE if x is of class longline, False otherwise\n#\n#' @examples\n#' N <- 20\n#' n <- rep(200,N)\n#' s <- rep(100, N)\n#' dataSim <- rmultinom(n=N, size=n, prob=c(.3, .1, .2, .4) )\n#' testLongline <- longline(fact1 = as.factor(sample(2004:2006, size=N,\n#' replace=TRUE)), nb=dataSim[,1], nt=dataSim[,2], nnt=dataSim[,3], ne=dataSim[,4], s=s)\n#' is.longline(testLongline)\n#' is.longline(x=2)\nis.longline <- function(x)\n{\n  return( inherits(x, \"longline\") )\n}\n\n\n# ExtractLongline\n#' ExtractLongline is a longline object extracts from the argument, which matches the condition fact1 and fact2\n#' \n#' @param x a object of class longline\n#' @param fact1 the value of Fact1 to be used for extraction\n#' @param fact2 the value of Fact2 to be used for extraction\n#' @param ind if provided, only the individuals ind will be extracted whatever fact2 and  fact1 are\n\n#' \n#' @export\n#' @return a longline object with only observations matching Fact1=fact1 and/or  optionnaly Fact2=fact2\n#\n#' @examples\n#' N <- 20\n#' n <- rep(200,N)\n#' s <- rep(100, N)\n#' dataSim <- rmultinom(n=N, size=n, prob=c(.3, .1, .2, .4) )\n#' testLongline <- longline(fact1 = as.factor(sample(2004:2006, size=N,\n#' replace=TRUE)), nb=dataSim[1,], nt=dataSim[2,], nnt=dataSim[3,], ne=dataSim[4,], s=s)\n#' ex <- ExtractLongline(testLongline, fact1=\"2004\")\n#' print(ex)\nExtractLongline <- function(x, fact1=NULL, fact2=NULL, ind=NULL)\n{  \n  if(is.null(ind))\n  {\n   if(is.null(fact1)&is.null(fact2))\n    ind <- 1:(x$NData) \n   if( is.null(fact1) & (!is.null(fact2)))\n     ind <- which(x$Fact2%in%fact2) \n   if( !is.null(fact1) & (is.null(fact2)))\n     ind <- which(x$Fact1%in%fact1) \n   if( (!is.null(fact1)) & (!is.null(fact2)))\n     ind <- which( (x$Fact1%in%fact1) & (x$Fact2%in%fact2)) \n  }\n  \n  res<- lapply(names(x), function(d){\n     switch(d, \n            NData=length(ind),\n            NFact1=nlevels(droplevels(x$Fact1[ind])),\n            Fact1=droplevels(x$Fact1[ind]),\n            NFact2=nlevels(droplevels(x$Fact2[ind])),\n            Fact2=droplevels(x$Fact2[ind]),\n            Ne=x$Ne[ind],\n            N=x$N[ind],\n            NT=x$NT[ind],\n            NNT=x$NNT[ind],\n            Nb=x$Nb[ind],\n            S=x$S[ind],\n            sameS = x$sameS\n     )\n   })\n  names(res)=names(x)\n  class(res) <- c(\"longline\", \"list\")\n  return(res)\n}\n\n\n# ComputeCPUE.longline\n#' ComputeCPUE.longline computes classical CPUE according to Fact1 and Fact2\n#' \n#' @param x a longline object\n#' @export\n#' @return classical CPUE  computed for every level of Fact1 and Fact2\n#\n#' @examples\n#' data(longlineEx)\n#' ll1 <- longline(fact1=longlineData$Year, fact2=longlineData$Area,  nt=longlineData$NT, nnt=longlineData$NNT, nb=longlineData$Nb, ne=longlineData$Ne, s=longlineData$soaktime)\n#' ComputeCPUE.longline(ll1)\n#' ll2 <- longline(fact1=longlineData$Year, nt=longlineData$NT, nnt=longlineData$NNT, nb=longlineData$Nb, ne=longlineData$Ne, s=longlineData$soaktime)\n#' ComputeCPUE.longline(ll2)\nComputeCPUE.longline<- function(x)\n{\n  \n  if(with(x,  exists(\"Fact2\"))){\n    x$FComb <- paste0(x$Fact1, \"-\", x$Fact2 )\n  }  else{\n    x$FComb <- x$Fact1\n  }\n  x$FComb <- as.factor(x$FComb)\n  res<- lapply(levels(x$FComb), function(d){\n    ind <- which(x$FComb == d)\n    ll <- ExtractLongline(x,  ind=ind)\n    if(with(x,  exists(\"Fact2\")))\n    {\n      ID  <- strsplit(d, split = \"-\")[[1]]\n     prov <- data.frame(Fact1=ID[1],  Fact2=ID[2], CPUE=sum(ll$NT) / sum(ll$S*ll$N))\n    }else   {\n      prov <- data.frame(Fact1=d,   CPUE=sum(ll$NT) / sum(ll$S*ll$N))\n    }\n    return(prov)\n    })\n  res <- Reduce('rbind', res)\n  \n  return(res)\n}\n",
    "created" : 1426606535259.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4253990631",
    "id" : "68EC30E",
    "lastKnownWriteTime" : 1426664360,
    "path" : "~/EnCours/PackageDvp/Svn/longline/R/longlineData.R",
    "project_path" : "R/longlineData.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}