{
    "contents" : "##############################################################\n## Method 2  : ML estimation \n##############################################################\n\n## script to perform the ML estimation of the complete exponetial model\n## If the data are store in a file longlineData.csv,\n## We may just use function Analysis with \n## subdata the dataframe which stored the data to be analyzed\n##############################################################################\n\n\n# MEM.MLE\n#' MEM.MLE computes MLE for data with several years and area, one lambda1, lambda2, pe computes for each(year,area)\n#' \n#' @param llData a object of class longline\n#' @param MEM the type of model (possible values 1 or 2)\n#' @param sameS, should all soaktime be considered as equal ?\n#' \n#' @export\n#' @return a vetor estimates of hat.lmabdaT, hat.lambda.NT, hat.pT, hat.pNT\n#\nMEM.MLE <- function(llData, MEM=1, sameS=T) \n{\n  adjustFact <- with(llData, exists(\"Fact2\"))\n  if(sameS){\n    llData$sameS=T\n   }\n  if(adjustFact) {\n    llData$Fact1 <- as.factor(with(llData, paste0(Fact1, \"-\", Fact2 )))\n    llData$Fact2 <- NULL\n    llData$NFact2 <- NULL\n  }      \n\n  res<- lapply(levels(llData$Fact1), function(d){\n    subdata <- ExtractLongline(llData, fact1 = d)\n    tt <-MEM.MLE.YA(subdata=subdata, MEM=MEM)\n    return(tt)\n  })\n  \n  estimate <- do.call(\"rbind\", res)\n  colnames(estimate) <- c(\"hat.lambda1\", \"hat.lambda2\", \"hat.pT\", \"hat.pNT\")\n  estimate <- as.data.frame(estimate)\n  estimate$Group <- levels(llData$Fact1)\n  return(estimate)\n}\n\n\n\n\n#### mem.mle.YA computes MEM MLE for one year in one area\nMEM.MLE.YA <- function(subdata, MEM=1) \n{\n  ## initial values for minimization algorithm\n  if(!is.longline(subdata))\n  {\n    stop(\"Argument 1 of function MEM.MLE is not of class longline\")\n  } else if( sum( subdata$NT+subdata$NNT) == 0)\n  {\n    return(list( lambda = c( , NA,NA, NA,NA ) ) ) ## no possible estimation\n  } else if(subdata$sameS)     \n  {\n    ne.missing <- (sum(is.na(subdata$Ne))==subdata$NData)\n    if(MEM==1) \n    {\n      return(Mem1MleSameP(subdata, ne.missing=ne.missing))\n    }else if(MEM==2)\n    {\n      return(Mem2MleSameP(subdata, ne.missing=ne.missing))\n    }             \n  } else\n  {\n    ne.missing <- (sum(is.na(subdata$Ne))==subdata$NData)\n    if(MEM==1) \n    {\n      return(Mem1MleGeneral(subdata, ne.missing=ne.missing))\n    } else\n    {\n      return(Mem1MleGeneral(subdata, ne.missing=ne.missing))\n    }\n  }\n}\n\n\n################################################\n## Estimators for MEM1 with shared soaktime P\n###############################################\nMem1MleSameP <- function(subdata, ne.missing=F)\n{\n  with(subdata,\n    {\n      hat.lambda1=sum( NT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      hat.lambda1 <- max(1e-7, hat.lambda1)\n      if(ne.missing)\n      {\n        hat.lambda2=sum( NNT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n        hat.p2 = 0.5\n      }else\n       {\n         hat.lambda2=sum( NNT + Ne) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n         hat.p2 = sum(Ne)/ sum(Ne+NNT)\n         \n       } \n      \n      hat.p1 =0\n      return(c(hat.lambda1, hat.lambda2, hat.p1, hat.p2))\n    }\n  )\n}\n\n################################################\n## Estimators for MEM2 with shared soaktime P\n###############################################\nMem2MleSameP <- function(subdata, ne.missing=F)\n{\n  with(subdata,\n    {\n      hat.lambda1=sum( NT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      hat.lambda2=sum( NNT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n     if(ne.missing)\n     {\n       hat.p2=0.5\n       hat.p1=0.5\n     }else\n     {\n        hat.p2 = sum( Ne )/ sum( N - Nb )\n        hat.p1 =  hat.p2 \n     }\n      return(c(hat.lambda1, hat.lambda2, hat.p1, hat.p2))\n    }\n  )\n}\n\n################################################\n## Estimators for MEM1 general case\n###############################################\nMem1MleGeneral <- function(subdata, ne.missing=F)\n{\n  with(subdata,\n    {                                    \n      lambda1.init = sum( NT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb)) \n      if(ne.missing)\n      {\n      lambda2.init = sum( NNT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      p            = 0.5\n      }else\n      {\n        lambda2.init = sum( NNT + Ne ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n        p            = sum( Ne )/ sum( Ne + NNT)\n      }\n      theta.mem1 = c(log(lambda1.init), log(lambda2.init), log(p/(1-p) ) )\n      if(ne.missing)\n        par.mem1   = theta.mem1\n      else\n        {\n        optim.mem1 = optim(theta.mem1, LogLike.MEM1, method=\"BFGS\", control=list(fnscale=-1),  subdata=subdata)\n        par.mem1   = optim.mem1$par \n        }\n      return( c(exp(par.mem1[1:2]), 0, exp(par.mem1[3]) / (1 + exp(par.mem1[3]) )) )\n    }\n  )\n}\n\n\n################################################\n## Estimators for MEM2 general case\n###############################################\nMem2MleGeneral <- function(subdata, ne.missing=F)\n{\n  with(subdata,\n    {\n      lambda1.init = sum( NT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb)) \n      lambda2.init = sum( NNT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      if(ne.missing)\n      {\n        p            = 0.5\n      }else\n      {\n        p            = sum( Ne )/ sum( Ne + NNT + NT )\n      }\n      theta.mem2 = c(log(lambda1.init), log(lambda2.init), log(p/(1-p)))\n      if(ne.missing)\n        par.mem2   = theta.mem2\n      else\n        {\n          optim.mem2 = optim(theta.mem2, LogLike.MEM2, method=\"BFGS\", control=list(fnscale=-1), subdata=subdata)\n        par.mem2   = optim.mem2$par \n        }\n      return( c(par.mem2, par.mem2[3]) )\n    }\n  )\n}\n\n\n\n######################################################\n##   General LogLikelihood \n######################################################\n## only when Ne is not missing\nLogLike <- function(theta,  subdata)\n{\n\n    ## theta = c(log(lambda1), log(lambda2), logit(p1), logit(p2))\n  lambda1 = exp(theta[1])\n  lambda2 = exp(theta[2])\n  p1      = exp(theta[3]) / ( 1 + exp(theta[3]) )\n  p2      = exp(theta[4]) / ( 1 + exp(theta[4]) )\n  \n  with(subdata,\n       {\n       lambda=lambda1+lambda2\n      return (\n        sum( lgamma(N+1)-lgamma(Nb+1)-lgamma(NT+1)-lgamma(NNT+1)-lgamma(Ne+1) ) - sum(lambda * S * Nb) +\n        sum( (N-Nb) * log (1 - exp( -lambda * S) ) ) + sum(NT * log(  lambda1 / lambda * ( 1-p1) ) )+ \n        sum( NNT * log(  lambda2 / lambda * ( 1-p2) ) ) + sum ( Ne * log(  (lambda1 *p1 + lambda2 * p2) / lambda ) )\n        )\n    }\n  )\n}\n\n######################################################\n##   MEM LogLikelihood\n######################################################\n## only when Ne is not missing\nLogLike.MEM1 <- function(theta.mem1,  subdata)\n{                                                    \n  ## theta.mem1 = c(log(lambda1), log(lambda2), logit(p2))\n  return( LogLike( c(theta.mem1[1:2], -Inf, theta.mem1[3]), subdata=subdata ) )\n}\n\nLogLike.MEM2 <- function(theta.mem2,  subdata)\n{\n  ## theta.mem2 = c(log(lambda1), log(lambda2), logit(p))\n  return( LogLike( c(theta.mem2[1:2], theta.mem2[3], theta.mem2[3] ), subdata=subdata ) )\n}\n\n\n\n######################################################\n##   MEM1 AIC\n######################################################\n## only when Ne is not missing\nAIC.Mem1 <- function(subdata)\n{\n   with(subdata,\n    {\n      lambda1.init = sum( NT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb)) \n      lambda2.init = sum( NNT ) / ( mean(S) * sum( (N - Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      p            = sum( Ne )/ sum( Ne + NNT )\n      theta.mem1 = c(log(lambda1.init), log(lambda2.init), log(p/(1-p)))\n      optim.mem1 = optim(theta.mem1, LogLike.MEM1, method=\"BFGS\", control=list(fnscale=-1), subdata=subdata)\n      return( -2 * optim.mem1$value + 6)\n    }\n    )\n}\n\n######################################################\n##   MEM2 AIC\n######################################################\n## only when Ne is not missing\nAIC.Mem2 <- function(subdata)\n{\n   with(subdata,\n    {\n      lambda1.init = sum( NT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb)) \n      lambda2.init = sum( NNT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) since all p are supposed to be equal or can be considered as equal\n      p            = sum( Ne )/ sum( Ne + NNT + NT )\n      theta.mem2 = c(log(lambda1.init), log(lambda2.init), log(p/(1-p)))\n      \n      optim.mem2 = optim(theta.mem2, LogLike.MEM2, method=\"BFGS\", control=list(fnscale=-1), subdata=subdata)\n      return( -2 * optim.mem2$value + 6)\n    }\n    )\n}\n\n\n######################################################\n##   Profile likelihood for lambda1 in MEM1\n######################################################\n## only when Ne is not missing\nProfile.MEM <- function(lambda1, subdata, MEM=1)\n{\n  ## lambda 1 is a vector \n  with(subdata,\n       {\n         return( sapply(lambda1, PartialLogLike, subdata=subdata, MEM=MEM))\n      }\n  )\n}\n######################################################\n##   Partial likelihood for lambda1 in MEM1\n##  optimized according other parameters\n######################################################\n## only when Ne is not missing\nPartialLogLike.MEM<- function(lambda1, subdata, MEM=1)\n{\n  with(subdata,\n       {\n         if(MEM==1)\n           {\n             lambda2.init = sum( NNT + Ne) / ( mean(S) * sum( (N- Nb) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) : initial guess\n             p2           = sum( Ne )/ sum( Ne + NNT )\n             theta.mem1 = c( log(lambda2.init), log(p2/(1-p2)))\n             ## definition of the function to be optimized only on lambda2 and p2\n             partlog <- function(theta.mem1)\n               {\n                 return (LogLike.MEM1(c(log(lambda1), theta.mem1), subdata=subdata) )\n               }\n             optim.mem1 = optim(theta.mem1 , partlog, method=\"SANN\", control=list(fnscale=-1))\n             return( optim.mem1$value )\n           }else if(MEM==2)\n           {\n             lambda2.init = sum( NNT ) / ( mean(S) * sum( (NT + NNT) ) ) * log( sum(N) / sum(Nb))  # P=mean(P) : initial guess\n             p            = sum( Ne )/ sum( Ne + NNT  + NT)\n             theta.mem2   = c( log(lambda2.init), log(p/(1-p)))\n             ## definition of the function to be optimized only on lambda2 and p2\n             partlog <- function(theta.mem2)\n               {\n                 return (LogLike.MEM2(c(log(lambda1), theta.mem2), subdata=subdata) )\n               }\n             optim.mem2 = optim(theta.mem2 , partlog, method=\"BFGS\", control=list(fnscale=-1))\n             return( optim.mem2$value )\n           }\n       }\n  )\n}\n\n\n#################################################\n##Prediction of expected values\n##\n#################################################\n## only when Ne is not missing\nPrediction.MEM <-  function(theta, subdata)\n{\n  lambda1=theta[1]\n  lambda2=theta[2]\n  lambda=lambda1+lambda2\n  p1=theta[3]\n  p2=theta[4]\n  with(subdata,\n       {\n         NT.pred= N*(1-exp(-lambda * P)) * lambda1 /lambda *(1-p1)\n         NNT.pred= N*(1-exp(-lambda * P)) * lambda2 /lambda *(1-p2)\n         Ne.pred= N*(1-exp(-lambda * P)) * (lambda1*p1 +lambda2*p2) /lambda\n         return(list(NT.pred=NT.pred, NNT.pred=NNT.pred, Ne.pred=Ne.pred))\n       }\n       )\n  }\n\n\n################################################\n## Covariance matrix asymptotic\n## only valid if all P are similar\n###############################################\n## only when Ne is not missing\nMEM.Cov <- function(subdata, MEM=1)\n  {\n    S=mean(subdata$S)\n    theta=MEM.MLE(subdata, MEM=MEM)\n    lambda1   = theta[1]\n    lambda2   = theta[2]\n    p1        = theta[3]\n    p2        = theta[4]\n    lambda    = lambda1+lambda2\n    moinsexp = 1-exp(-lambda*S)\n\n    if(MEM==1)\n      {\n        mat= matrix(c(lambda1*lambda2 / moinsexp + moinsexp *lambda1^2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          -lambda1*lambda2 / moinsexp + moinsexp *lambda1*lambda2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          0,\n          -lambda1*lambda2 / moinsexp + moinsexp *lambda1*lambda2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          lambda1*lambda2 / moinsexp + moinsexp *lambda2^2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          0,\n          0,\n          0,\n          lambda*p2*(1-p2)/ (lambda2 * moinsexp)), byrow=T, ncol=3)\n      }else if( MEM==2)\n      {\n      mat= matrix(c(lambda1*lambda2 / ((1-p2)* moinsexp) + moinsexp *lambda1^2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          -lambda1*lambda2 / ((1-p2)* moinsexp) + moinsexp *lambda1*lambda2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          0,\n          -lambda1*lambda2 / ((1-p2)* moinsexp) + moinsexp *lambda1*lambda2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          lambda1*lambda2 / ((1-p2)* moinsexp) + moinsexp *lambda2^2 / ( S^2 * exp(-lambda *S) * lambda^2),\n          0,\n          0,\n          0,\n          p2*(1-p2)/ (moinsexp)), byrow=T, ncol=3)\n        \n      }\n      \n    \n    return(1/sum(subdata$N) * mat)\n  }\n\n\n  MEM.Fisher <- function(theta, S, MEM=1)\n  {\n    lambda1   = theta[1]\n    lambda2   = theta[2]\n    p1        = theta[3]\n    p2        = theta[4] \n    p         = p1               \n    lambda    = lambda1+lambda2\n    moinsexp = 1-exp(-lambda*S)\n\n    if(MEM==1)\n      {\n        mat= matrix(c(S*S * exp(-lambda * S) / moinsexp + moinsexp /( lambda) *(1/lambda1 - 1/lambda),\n                      S*S * exp(-lambda * S) / moinsexp + moinsexp /( lambda*lambda),\n                      0,\n                      S*S * exp(-lambda * S) / moinsexp + moinsexp /( lambda*lambda),\n                      S*S * exp(-lambda * S) / moinsexp + moinsexp /( lambda) *(1/lambda2 - 1/lambda),\n                      0,\n                      0,\n                      0,\n                      (lambda2 * moinsexp)/(lambda  *p2*(1-p2) ))\n        , byrow=T, ncol=3)\n      }else if( MEM==2)\n      {\n        mat= matrix(c(S*S * exp(-lambda * S) / moinsexp + (1-p) * moinsexp /( lambda * lambda ) *(lambda2 /lambda1),\n                      S*S * exp(-lambda * S) / moinsexp - (1-p)  * moinsexp /( lambda*lambda),\n                      0,\n                      S*S * exp(-lambda * S) / moinsexp - (1-p)  * moinsexp /( lambda*lambda),\n                      S*S * exp(-lambda * S) / moinsexp + (1-p) * moinsexp /( lambda * lambda ) *(lambda1 /lambda2),\n                      0,\n                      0,\n                      0,\n                      (moinsexp)/(p*(1-p) ))\n        , byrow=T, ncol=3) \n      }\n    return(mat)\n  }\n",
    "created" : 1426237690265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1632400429",
    "id" : "54D6EA17",
    "lastKnownWriteTime" : 1426608769,
    "path" : "~/EnCours/PackageDvp/Svn/longline/R/MEM.R",
    "project_path" : "R/MEM.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}